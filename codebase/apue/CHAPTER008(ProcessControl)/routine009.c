/**
 * SUBJECT: Process Termination - 'exec' functions
 * AUTHOR: LiYing
 * TIME: 2009-10-22 14:31:22
 */
/**
 *(EXECL, EXECV) * (NULL, E, P)
 *        NULL  E      P
 * EXECL: EXECL EXECLE EXECLP
 * EXECV: EXECV EXECVE EXECVP
 */
/**
 * EXECL FUNCTIONS -- execute a file
 * #include<unistd.h>
 * extern char *environ;
 * int execl(const char *path,
 * 			 const char *arg0,
 *           ...
 *           //[const char *arg1,...,const char *argn,]
 *          (char *)0
 * );
 * int execle(const char *path,
 *            const char *arg0,
 *            ...
 *            //[const char *arg1,...,const char *argn,]
 *           (char *)0
 *           const char *envp[]
 *);
 * int execlp(const char *file,
 *            const char *arg0,
 *            ...
 *            //[const char *arg1,...,const char *argn,]
 *           (char *)0
 *);
 */
/**
 * EXECV FUNCTIONS
 * #include<unistd.h>
 * extern char *environ;
 * int execv(const char *path,
 *           char * const argv[]);
 * int execve(const char *path,
 *            char * const argv[],
 *            char * const envp[]);
 * int execvp(const char *file,
 *            char * const argv[]);
 */
/**
 * returns: one on error, no return on success
 */
/**
 * PATHNAME VS FILENAME
 * 1.Filename will be taken as a pathname, if it contains a slash, otherwise
 * 2.the executable file is searched for in the dir specified by the PATH environment variable
 * 3.PATH=/bin/:/usr/bin/:/usr/local/bin/:.
 * 4.PATH=prefix:prefix:prefix:prefix
 */
/**
 * EXECLP && EXECVP
 * Found an executable file using one of the path prefix:
 * 1.Machild executable file generated by the link editor: execute the file;
 * 2.Shell script: tries to invoke /bin/sh with the filename as input to the shell.
 */
/**
 * ARGUMENT-LIST
 * char *arg0, char *arg1, ..., char *argn, (char *)0
 * NOTE: cast the last argument to pointer to char
 */
/**
 * ENVIRONMENT-LIST
 * extern char **environ;
 */
/**
 * ARG_MAX
 */
/**
 * INHERITENCE
 * process id and parent process id
 * real user id and real group id
 * supplementary group id
 * process group id
 * session id
 * controlling terminal
 * time left until alarm clock
 * current working directory
 * root directory
 * file mode creation mask
 * file locks
 * process signal mask
 * pending signals
 * resource limits
 * values for tms_utime, tms_stime, tms_cutime and tms_cstime
 */
/**
 * close-on-exec of open files
 * 1.open accross exec on default
 * 2.using fcntl to set the close-on-exec flag
 */
/**
 * set-user-id && set-group-id
 * effective user id is set to the owner id of the program file
 * if set-user-id is set.
 */
/**
 * RELATIONSHIP OF THE SIX FUNCTIONS
 * execve  <--  execv  <--  execvp
 *    |           |            |
 * execle		execl		execlp
 */
/**
 * THE SYSTEM CALL IS 'EXECVE'
 * 1.argument vector building
 * 2.searching PATH (try each PATH prefix)
 * 3.use 'environ' as envp
 */

#include<stdio.h>
#include<string.h>
#include<unistd.h>

extern int errno;

char *env_init[] = {"USER=unknown", "PATH=/tmp", NULL};

int main(int argc, char *argv[]){
	pid_t pid;

	if ((pid = fork()) < 0){
		printf("fork error\n");
		exit(-1);
	}/*fork fail*/
	else if (pid == 0){
		if (execle("/atiitest/testsrc/apue/CHPATER008/echoall", "echoall", "myarg1", "MY ARG2", (char *)0, env_init) < 0){
			printf("exec fail\n");
			printf("%s\n", strerror(errno));
			exit(-2);
		}/*exec fail*/
	}/*child*/

	if (waitpid(pid, NULL, 0) < 0){
		printf("wait fail\n");
		printf("%s\n", strerror(errno));
		exit(-1);
	}/*wait fail*/

	if ((pid = fork()) < 0){
		printf("fork error\n");
		exit(-1);
	}/*fork fail*/
	else if (pid == 0){
		if (execlp("echoall","echoall", "myarg1", "MY ARG2", (char *)0) < 0){
			printf("exec fail\n");
			exit(-2);
		}/*exec fail*/
	}/*child*/
	exit(0);
}/*main*/
